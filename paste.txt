#include <ros/ros.h>

#include <sensor_msgs/PointCloud2.h>
#include <visualization_msgs/MarkerArray.h>
#include <visualization_msgs/Marker.h>

#include <pcl_conversions/pcl_conversions.h>
#include <pcl_ros/point_cloud.h>

#include <pcl/point_types.h>
#include <pcl/filters/voxel_grid.h>
#include <pcl/filters/passthrough.h>
#include <pcl/filters/extract_indices.h>

#include <pcl/segmentation/sac_segmentation.h>
#include <pcl/segmentation/extract_clusters.h>
#include <pcl/search/kdtree.h>

#include <Eigen/Dense>
#include <unordered_map>
#include <limits>
#include <string>
#include <vector>

using PointT = pcl::PointXYZI;

struct Track {
  int id = -1;
  ros::Time last_seen;
  Eigen::Vector3f pos;   // center (x,y,z)
  Eigen::Vector3f vel;   // simple velocity
  Eigen::Vector3f size;  // box dimensions
};

class ObjectBoxesTracker {
public:
  ObjectBoxesTracker(ros::NodeHandle& nh, ros::NodeHandle& pnh)
  : nh_(nh), pnh_(pnh) {
    // Params (tune these)
    pnh_.param<std::string>("input_topic", input_topic_, "/unilidar/cloud");
    pnh_.param<std::string>("objects_cloud_topic", objects_cloud_topic_, "/objects_cloud");
    pnh_.param<std::string>("boxes_topic", boxes_topic_, "/detected_boxes");
    pnh_.param<std::string>("labels_topic", labels_topic_, "/track_labels");

    pnh_.param<std::string>("fixed_frame", fixed_frame_, "unilidar_lidar");

    pnh_.param<double>("voxel_leaf", voxel_leaf_, 0.06);          // m
    pnh_.param<double>("z_min", z_min_, -1.5);                    // m
    pnh_.param<double>("z_max", z_max_,  2.5);                    // m

    pnh_.param<bool>("remove_ground", remove_ground_, true);
    pnh_.param<double>("ground_dist_thresh", ground_dist_thresh_, 0.08); // m
    pnh_.param<int>("ground_max_iters", ground_max_iters_, 80);

    pnh_.param<double>("cluster_tol", cluster_tol_, 0.35);        // m
    pnh_.param<int>("cluster_min", cluster_min_, 70);
    pnh_.param<int>("cluster_max", cluster_max_, 30000);

    pnh_.param<double>("assoc_dist", assoc_dist_, 0.8);           // m
    pnh_.param<double>("track_timeout", track_timeout_, 0.9);     // s

    pnh_.param<double>("box_alpha", box_alpha_, 0.85);
    pnh_.param<double>("box_z_lift", box_z_lift_, 0.0);           // lift boxes up if needed

    sub_ = nh_.subscribe(input_topic_, 1, &ObjectBoxesTracker::cb, this);

    pub_objects_ = nh_.advertise<sensor_msgs::PointCloud2>(objects_cloud_topic_, 1);
    pub_boxes_   = nh_.advertise<visualization_msgs::MarkerArray>(boxes_topic_, 1);
    pub_labels_  = nh_.advertise<visualization_msgs::MarkerArray>(labels_topic_, 1);

    ROS_INFO("object_boxes_tracker subscribed to: %s", input_topic_.c_str());
  }

private:
  void cb(const sensor_msgs::PointCloud2ConstPtr& msg) {
    pcl::PointCloud<PointT>::Ptr cloud(new pcl::PointCloud<PointT>());
    pcl::fromROSMsg(*msg, *cloud);
    if (!cloud || cloud->empty()) return;

    // 1) Voxel downsample
    pcl::PointCloud<PointT>::Ptr ds(new pcl::PointCloud<PointT>());
    {
      pcl::VoxelGrid<PointT> vg;
      vg.setInputCloud(cloud);
      vg.setLeafSize(voxel_leaf_, voxel_leaf_, voxel_leaf_);
      vg.filter(*ds);
    }

    // 2) PassThrough on Z (keeps "road region")
    pcl::PointCloud<PointT>::Ptr zf(new pcl::PointCloud<PointT>());
    {
      pcl::PassThrough<PointT> pass;
      pass.setInputCloud(ds);
      pass.setFilterFieldName("z");
      pass.setFilterLimits(z_min_, z_max_);
      pass.filter(*zf);
    }
    if (zf->empty()) return;

    // 3) Remove ground plane (optional)
    pcl::PointCloud<PointT>::Ptr noground(new pcl::PointCloud<PointT>());
    if (remove_ground_) {
      pcl::SACSegmentation<PointT> seg;
      seg.setOptimizeCoefficients(true);
      seg.setModelType(pcl::SACMODEL_PERPENDICULAR_PLANE);
      seg.setMethodType(pcl::SAC_RANSAC);
      seg.setMaxIterations(ground_max_iters_);
      seg.setDistanceThreshold(ground_dist_thresh_);

      // Perpendicular to Z axis (ground normal roughly Z)
      Eigen::Vector3f axis(0.f, 0.f, 1.f);
      seg.setAxis(axis);
      seg.setEpsAngle(static_cast<float>(15.0 * M_PI / 180.0)); // 15 degrees

      pcl::PointIndices::Ptr inliers(new pcl::PointIndices());
      pcl::ModelCoefficients::Ptr coeff(new pcl::ModelCoefficients());
      seg.setInputCloud(zf);
      seg.segment(*inliers, *coeff);

      if (inliers->indices.size() > 50) {
        pcl::ExtractIndices<PointT> ex;
        ex.setInputCloud(zf);
        ex.setIndices(inliers);
        ex.setNegative(true); // remove ground
        ex.filter(*noground);
      } else {
        *noground = *zf; // no ground found -> keep all
      }
    } else {
      *noground = *zf;
    }
    if (noground->empty()) return;

    // Publish objects cloud for RViz clarity
    {
      sensor_msgs::PointCloud2 out;
      pcl::toROSMsg(*noground, out);
      out.header = msg->header;
      out.header.frame_id = msg->header.frame_id; // keep original frame
      pub_objects_.publish(out);
    }

    // 4) Euclidean clustering
    std::vector<pcl::PointIndices> cluster_indices;
    {
      pcl::search::KdTree<PointT>::Ptr tree(new pcl::search::KdTree<PointT>());
      tree->setInputCloud(noground);

      pcl::EuclideanClusterExtraction<PointT> ec;
      ec.setClusterTolerance(cluster_tol_);
      ec.setMinClusterSize(cluster_min_);
      ec.setMaxClusterSize(cluster_max_);
      ec.setSearchMethod(tree);
      ec.setInputCloud(noground);
      ec.extract(cluster_indices);
    }

    // Build detections (AABB boxes)
    struct Detection {
      Eigen::Vector3f center;
      Eigen::Vector3f size;
      int pts = 0;
    };
    std::vector<Detection> dets;
    dets.reserve(cluster_indices.size());

    for (const auto& ci : cluster_indices) {
      if (ci.indices.empty()) continue;

      float minx= std::numeric_limits<float>::infinity();
      float miny= std::numeric_limits<float>::infinity();
      float minz= std::numeric_limits<float>::infinity();
      float maxx=-std::numeric_limits<float>::infinity();
      float maxy=-std::numeric_limits<float>::infinity();
      float maxz=-std::numeric_limits<float>::infinity();

      for (int idx : ci.indices) {
        const auto& p = noground->points[idx];
        if (!std::isfinite(p.x) || !std::isfinite(p.y) || !std::isfinite(p.z)) continue;
        minx = std::min(minx, p.x); miny = std::min(miny, p.y); minz = std::min(minz, p.z);
        maxx = std::max(maxx, p.x); maxy = std::max(maxy, p.y); maxz = std::max(maxz, p.z);
      }

      Eigen::Vector3f size(maxx-minx, maxy-miny, maxz-minz);
      // reject tiny noise
      if (size.x() < 0.10f || size.y() < 0.10f || size.z() < 0.10f) continue;

      Eigen::Vector3f center((minx+maxx)/2.f, (miny+maxy)/2.f, (minz+maxz)/2.f + (float)box_z_lift_);
      Detection d;
      d.center = center;
      d.size = size;
      d.pts = (int)ci.indices.size();
      dets.push_back(d);
    }

    // 5) Track association (greedy nearest neighbor)
    const ros::Time now = msg->header.stamp.isZero() ? ros::Time::now() : msg->header.stamp;

    // Predict existing tracks
    for (auto& kv : tracks_) {
      Track& t = kv.second;
      double dt = (now - t.last_seen).toSec();
      if (dt > 0.0 && dt < 1.0) {
        t.pos = t.pos + t.vel * (float)dt;
      }
    }

    std::vector<int> det_to_track(dets.size(), -1);
    std::unordered_map<int, bool> used_track;
    used_track.reserve(tracks_.size());

    for (size_t i = 0; i < dets.size(); i++) {
      float best = (float)assoc_dist_;
      int best_id = -1;

      for (auto& kv : tracks_) {
        int tid = kv.first;
        if (used_track[tid]) continue;

        Track& t = kv.second;
        float dist = (t.pos - dets[i].center).norm();
        if (dist < best) {
          best = dist;
          best_id = tid;
        }
      }

      if (best_id >= 0) {
        det_to_track[i] = best_id;
        used_track[best_id] = true;
      }
    }

    // Update / create tracks
    for (size_t i = 0; i < dets.size(); i++) {
      const auto& d = dets[i];
      int tid = det_to_track[i];

      if (tid >= 0) {
        Track& t = tracks_[tid];
        double dt = std::max(1e-3, (now - t.last_seen).toSec());
        Eigen::Vector3f new_vel = (d.center - t.pos) / (float)dt;

        // Smooth velocity and position a bit (reduces jitter)
        t.vel = 0.6f * t.vel + 0.4f * new_vel;
        t.pos = 0.5f * t.pos + 0.5f * d.center;
        t.size = 0.6f * t.size + 0.4f * d.size;
        t.last_seen = now;
      } else {
        Track t;
        t.id = next_id_++;
        t.pos = d.center;
        t.size = d.size;
        t.vel = Eigen::Vector3f(0,0,0);
        t.last_seen = now;
        tracks_[t.id] = t;
      }
    }

    // Remove stale tracks
    std::vector<int> to_del;
    for (auto& kv : tracks_) {
      const Track& t = kv.second;
      if ((now - t.last_seen).toSec() > track_timeout_) {
        to_del.push_back(kv.first);
      }
    }
    for (int id : to_del) tracks_.erase(id);

    // 6) Publish markers (boxes + labels)
    visualization_msgs::MarkerArray box_arr;
    visualization_msgs::MarkerArray label_arr;

    int box_idx = 0;
    for (auto& kv : tracks_) {
      const Track& t = kv.second;

      visualization_msgs::Marker box;
      box.header.frame_id = msg->header.frame_id;
      box.header.stamp = now;
      box.ns = "tracked_boxes";
      box.id = t.id;
      box.type = visualization_msgs::Marker::CUBE;
      box.action = visualization_msgs::Marker::ADD;

      box.pose.position.x = t.pos.x();
      box.pose.position.y = t.pos.y();
      box.pose.position.z = t.pos.z();
      box.pose.orientation.w = 1.0; // axis-aligned

      box.scale.x = std::max(0.05f, t.size.x());
      box.scale.y = std::max(0.05f, t.size.y());
      box.scale.z = std::max(0.05f, t.size.z());

      // Color: green boxes
      box.color.r = 0.1f;
      box.color.g = 1.0f;
      box.color.b = 0.1f;
      box.color.a = (float)box_alpha_;

      // Make them persist smoothly in RViz
      box.lifetime = ros::Duration(0.35);

      box_arr.markers.push_back(box);

      visualization_msgs::Marker txt;
      txt.header = box.header;
      txt.ns = "track_labels";
      txt.id = t.id;
      txt.type = visualization_msgs::Marker::TEXT_VIEW_FACING;
      txt.action = visualization_msgs::Marker::ADD;
      txt.pose.position.x = t.pos.x();
      txt.pose.position.y = t.pos.y();
      txt.pose.position.z = t.pos.z() + 0.25;  // above box
      txt.pose.orientation.w = 1.0;
      txt.scale.z = 0.22; // text height
      txt.color.r = 1.0f;
      txt.color.g = 1.0f;
      txt.color.b = 1.0f;
      txt.color.a = 1.0f;
      txt.lifetime = ros::Duration(0.35);

      // show id + range
      float range = std::sqrt(t.pos.x()*t.pos.x() + t.pos.y()*t.pos.y());
      txt.text = "ID " + std::to_string(t.id) + "  r=" + to1(range) + "m";
      label_arr.markers.push_back(txt);

      (void)box_idx;
    }

    pub_boxes_.publish(box_arr);
    pub_labels_.publish(label_arr);
  }

  static std::string to1(float v) {
    char buf[32];
    std::snprintf(buf, sizeof(buf), "%.1f", v);
    return std::string(buf);
  }

private:
  ros::NodeHandle nh_, pnh_;
  ros::Subscriber sub_;
  ros::Publisher pub_objects_, pub_boxes_, pub_labels_;

  std::string input_topic_;
  std::string objects_cloud_topic_;
  std::string boxes_topic_;
  std::string labels_topic_;
  std::string fixed_frame_;

  double voxel_leaf_;
  double z_min_, z_max_;

  bool remove_ground_;
  double ground_dist_thresh_;
  int ground_max_iters_;

  double cluster_tol_;
  int cluster_min_;
  int cluster_max_;

  double assoc_dist_;
  double track_timeout_;

  double box_alpha_;
  double box_z_lift_;

  std::unordered_map<int, Track> tracks_;
  int next_id_ = 0;
};

int main(int argc, char** argv) {
  ros::init(argc, argv, "object_boxes_tracker");
  ros::NodeHandle nh;
  ros::NodeHandle pnh("~");

  ObjectBoxesTracker node(nh, pnh);
  ros::spin();
  return 0;
}