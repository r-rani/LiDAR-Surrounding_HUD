#include <ros/ros.h>
#include <sensor_msgs/PointCloud2.h>
#include <visualization_msgs/MarkerArray.h>

#include <pcl_conversions/pcl_conversions.h>
#include <pcl/point_types.h>
#include <pcl/point_cloud.h>

#include <pcl/filters/voxel_grid.h>
#include <pcl/filters/passthrough.h>

#include <pcl/search/kdtree.h>
#include <pcl/segmentation/extract_clusters.h>

#include <pcl/common/common.h>

class ObjectOutlines
{
public:
    ObjectOutlines()
    {
        ros::NodeHandle pnh("~");

        pnh.param("input_topic", input_topic_, std::string("/unitree_lidar/cloud"));
        pnh.param("fixed_frame", fixed_frame_, std::string("unitree_lidar"));

        pnh.param("voxel_leaf", voxel_leaf_, 0.03);
        pnh.param("z_min", z_min_, 0.2);
        pnh.param("z_max", z_max_, 2.5);

        pnh.param("cluster_tol", cluster_tol_, 0.35);
        pnh.param("cluster_min", cluster_min_, 15);
        pnh.param("cluster_max", cluster_max_, 40000);

        sub_ = nh_.subscribe(input_topic_, 1, &ObjectOutlines::cloudCallback, this);
        marker_pub_ = nh_.advertise<visualization_msgs::MarkerArray>("/detected_objects", 1);

        ROS_INFO("ObjectOutlines running. Subscribed to %s", input_topic_.c_str());
    }

private:
    ros::NodeHandle nh_;
    ros::Subscriber sub_;
    ros::Publisher marker_pub_;

    std::string input_topic_;
    std::string fixed_frame_;

    double voxel_leaf_;
    double z_min_, z_max_;
    double cluster_tol_;
    int cluster_min_, cluster_max_;

    void cloudCallback(const sensor_msgs::PointCloud2ConstPtr& msg)
    {
        pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);
        pcl::fromROSMsg(*msg, *cloud);

        if (cloud->empty()) return;

        // --- Downsample ---
        pcl::VoxelGrid<pcl::PointXYZ> vg;
        vg.setLeafSize(voxel_leaf_, voxel_leaf_, voxel_leaf_);
        vg.setInputCloud(cloud);

        pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_ds(new pcl::PointCloud<pcl::PointXYZ>);
        vg.filter(*cloud_ds);

        // --- Z filter (remove ground/ceiling) ---
        pcl::PassThrough<pcl::PointXYZ> pass;
        pass.setInputCloud(cloud_ds);
        pass.setFilterFieldName("z");
        pass.setFilterLimits(z_min_, z_max_);

        pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_f(new pcl::PointCloud<pcl::PointXYZ>);
        pass.filter(*cloud_f);

        if (cloud_f->size() < 10) return;

        // --- Clustering ---
        pcl::search::KdTree<pcl::PointXYZ>::Ptr tree(new pcl::search::KdTree<pcl::PointXYZ>);
        tree->setInputCloud(cloud_f);

        std::vector<pcl::PointIndices> cluster_indices;

        pcl::EuclideanClusterExtraction<pcl::PointXYZ> ec;
        ec.setClusterTolerance(cluster_tol_);
        ec.setMinClusterSize(cluster_min_);
        ec.setMaxClusterSize(cluster_max_);
        ec.setSearchMethod(tree);
        ec.setInputCloud(cloud_f);
        ec.extract(cluster_indices);

        visualization_msgs::MarkerArray markers;

        int id = 0;

        for (const auto& indices : cluster_indices)
        {
            pcl::PointCloud<pcl::PointXYZ>::Ptr cluster(new pcl::PointCloud<pcl::PointXYZ>);
            for (int idx : indices.indices)
                cluster->push_back((*cloud_f)[idx]);

            pcl::PointXYZ min_pt, max_pt;
            pcl::getMinMax3D(*cluster, min_pt, max_pt);

            float width  = max_pt.y - min_pt.y;
            float depth  = max_pt.x - min_pt.x;
            float height = max_pt.z - min_pt.z;

            // Ignore walls
            if (width > 3.0 || depth > 3.0)
                continue;

            bool is_person =
                height > 1.2 && height < 2.2 &&
                width  < 1.0 &&
                depth  < 1.0;

            visualization_msgs::Marker box;
            box.header.frame_id = fixed_frame_;
            box.header.stamp = ros::Time::now();
            box.ns = is_person ? "person" : "obstacle";
            box.id = id++;
            box.type = visualization_msgs::Marker::CUBE;
            box.action = visualization_msgs::Marker::ADD;

            box.pose.position.x = (min_pt.x + max_pt.x) / 2.0;
            box.pose.position.y = (min_pt.y + max_pt.y) / 2.0;
            box.pose.position.z = (min_pt.z + max_pt.z) / 2.0;

            box.pose.orientation.w = 1.0;

            box.scale.x = depth;
            box.scale.y = width;
            box.scale.z = height;

            box.color.a = 0.8;

            if (is_person)
            {
                box.color.r = 0.0;
                box.color.g = 1.0;
                box.color.b = 0.0;   // GREEN = PERSON
            }
            else
            {
                box.color.r = 1.0;
                box.color.g = 0.0;
                box.color.b = 0.0;   // RED = OBSTACLE
            }

            markers.markers.push_back(box);
        }

        marker_pub_.publish(markers);
    }
};

int main(int argc, char** argv)
{
    ros::init(argc, argv, "object_outlines");
    ObjectOutlines node;
    ros::spin();
    return 0;
}
