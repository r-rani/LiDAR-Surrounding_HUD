#include <ros/ros.h>
#include <sensor_msgs/PointCloud2.h>
#include <visualization_msgs/MarkerArray.h>
#include <visualization_msgs/Marker.h>
#include <geometry_msgs/Point.h>

#include <pcl_conversions/pcl_conversions.h>
#include <pcl_ros/point_cloud.h>

#include <pcl/point_types.h>
#include <pcl/filters/voxel_grid.h>
#include <pcl/filters/passthrough.h>
#include <pcl/filters/extract_indices.h>

#include <pcl/ModelCoefficients.h>
#include <pcl/segmentation/sac_segmentation.h>

#include <pcl/segmentation/extract_clusters.h>
#include <pcl/search/kdtree.h>

#include <pcl/surface/concave_hull.h>
#include <pcl/common/centroid.h>

#include <random>

class ObjectOutlinesNode {
public:
  ObjectOutlinesNode() : nh_("~"), marker_seq_(0) {
    nh_.param<std::string>("input_topic", input_topic_, std::string("/unilidar/cloud"));
    nh_.param<std::string>("fixed_frame", fixed_frame_, std::string("unilidar_lidar"));

    nh_.param<double>("voxel_leaf", voxel_leaf_, 0.08);

    // ROI cropping (very important to stop “everything in the room”)
    nh_.param<double>("x_min", x_min_, 0.0);
    nh_.param<double>("x_max", x_max_, 25.0);
    nh_.param<double>("y_min", y_min_, -8.0);
    nh_.param<double>("y_max", y_max_,  8.0);
    nh_.param<double>("z_min", z_min_, -2.0);
    nh_.param<double>("z_max", z_max_,  3.0);

    // Ground removal
    nh_.param<bool>("remove_ground", remove_ground_, true);
    nh_.param<double>("ground_dist_thresh", ground_dist_thresh_, 0.12);
    nh_.param<int>("ground_max_iters", ground_max_iters_, 80);

    // Wall/plane removal (repeat extracting big planes)
    nh_.param<bool>("remove_big_planes", remove_big_planes_, true);
    nh_.param<double>("plane_dist_thresh", plane_dist_thresh_, 0.10);
    nh_.param<int>("plane_max_iters", plane_max_iters_, 80);
    nh_.param<int>("max_planes_remove", max_planes_remove_, 2);
    nh_.param<int>("min_plane_inliers", min_plane_inliers_, 800);

    // Clustering
    nh_.param<double>("cluster_tol", cluster_tol_, 0.45);
    nh_.param<int>("cluster_min", cluster_min_, 60);
    nh_.param<int>("cluster_max", cluster_max_, 20000);

    // Outline
    nh_.param<double>("hull_alpha", hull_alpha_, 0.25); // smaller => tighter outline, too small => can fail

    sub_ = nh_.subscribe(input_topic_, 1, &ObjectOutlinesNode::cloudCb, this);
    pub_markers_ = nh_.advertise<visualization_msgs::MarkerArray>("/detected_outlines", 1);
    pub_objects_cloud_ = nh_.advertise<sensor_msgs::PointCloud2>("/objects_cloud", 1);

    ROS_INFO("ObjectOutlinesNode subscribed to: %s", input_topic_.c_str());
  }

private:
  ros::NodeHandle nh_;
  ros::Subscriber sub_;
  ros::Publisher pub_markers_;
  ros::Publisher pub_objects_cloud_;

  std::string input_topic_;
  std::string fixed_frame_;
  int marker_seq_;

  // Params
  double voxel_leaf_;
  double x_min_, x_max_, y_min_, y_max_, z_min_, z_max_;

  bool remove_ground_;
  double ground_dist_thresh_;
  int ground_max_iters_;

  bool remove_big_planes_;
  double plane_dist_thresh_;
  int plane_max_iters_;
  int max_planes_remove_;
  int min_plane_inliers_;

  double cluster_tol_;
  int cluster_min_, cluster_max_;
  double hull_alpha_;

  // Utility: random but stable-ish color per cluster id
  std_msgs::ColorRGBA colorFor(int id) {
    std_msgs::ColorRGBA c;
    std::mt19937 rng(id * 9973);
    std::uniform_real_distribution<float> dist(0.2f, 1.0f);
    c.r = dist(rng);
    c.g = dist(rng);
    c.b = dist(rng);
    c.a = 1.0f;
    return c;
  }

  void passthrough(pcl::PointCloud<pcl::PointXYZI>::Ptr cloud) {
    pcl::PassThrough<pcl::PointXYZI> pass;

    pass.setInputCloud(cloud);
    pass.setFilterFieldName("x");
    pass.setFilterLimits(x_min_, x_max_);
    pass.filter(*cloud);

    pass.setInputCloud(cloud);
    pass.setFilterFieldName("y");
    pass.setFilterLimits(y_min_, y_max_);
    pass.filter(*cloud);

    pass.setInputCloud(cloud);
    pass.setFilterFieldName("z");
    pass.setFilterLimits(z_min_, z_max_);
    pass.filter(*cloud);
  }

  void voxelDownsample(pcl::PointCloud<pcl::PointXYZI>::Ptr cloud) {
    pcl::VoxelGrid<pcl::PointXYZI> vg;
    vg.setInputCloud(cloud);
    vg.setLeafSize(voxel_leaf_, voxel_leaf_, voxel_leaf_);
    vg.filter(*cloud);
  }

  // Remove a single dominant plane; returns number of inliers removed
  int removeOnePlane(pcl::PointCloud<pcl::PointXYZI>::Ptr cloud, double dist_thresh, int max_iters) {
    pcl::SACSegmentation<pcl::PointXYZI> seg;
    seg.setOptimizeCoefficients(true);
    seg.setModelType(pcl::SACMODEL_PLANE);
    seg.setMethodType(pcl::SAC_RANSAC);
    seg.setMaxIterations(max_iters);
    seg.setDistanceThreshold(dist_thresh);

    pcl::PointIndices::Ptr inliers(new pcl::PointIndices);
    pcl::ModelCoefficients::Ptr coeff(new pcl::ModelCoefficients);

    seg.setInputCloud(cloud);
    seg.segment(*inliers, *coeff);

    if (inliers->indices.empty()) return 0;

    pcl::ExtractIndices<pcl::PointXYZI> extract;
    extract.setInputCloud(cloud);
    extract.setIndices(inliers);
    extract.setNegative(true); // remove plane
    pcl::PointCloud<pcl::PointXYZI>::Ptr filtered(new pcl::PointCloud<pcl::PointXYZI>);
    extract.filter(*filtered);
    cloud.swap(filtered);

    return (int)inliers->indices.size();
  }

  void cloudCb(const sensor_msgs::PointCloud2ConstPtr& msg) {
    pcl::PointCloud<pcl::PointXYZI>::Ptr cloud_raw(new pcl::PointCloud<pcl::PointXYZI>);
    pcl::fromROSMsg(*msg, *cloud_raw);

    if (cloud_raw->empty()) return;

    // 1) Crop to ROI
    passthrough(cloud_raw);

    // 2) Downsample
    voxelDownsample(cloud_raw);

    if (cloud_raw->size() < 50) return;

    // 3) Remove ground plane (dominant plane)
    if (remove_ground_) {
      int removed = removeOnePlane(cloud_raw, ground_dist_thresh_, ground_max_iters_);
      // If you keep seeing "Not enough inliers", increase ground_dist_thresh or ensure ROI includes ground.
      (void)removed;
    }

    // 4) Remove a couple more big planes (often walls/large table faces)
    if (remove_big_planes_) {
      for (int i = 0; i < max_planes_remove_; i++) {
        int removed = removeOnePlane(cloud_raw, plane_dist_thresh_, plane_max_iters_);
        if (removed < min_plane_inliers_) break;
      }
    }

    if (cloud_raw->size() < (size_t)cluster_min_) {
      publishEmptyMarkers(msg->header);
      return;
    }

    // 5) Euclidean clustering
    pcl::search::KdTree<pcl::PointXYZI>::Ptr tree(new pcl::search::KdTree<pcl::PointXYZI>);
    tree->setInputCloud(cloud_raw);

    std::vector<pcl::PointIndices> cluster_indices;
    pcl::EuclideanClusterExtraction<pcl::PointXYZI> ec;
    ec.setClusterTolerance(cluster_tol_);
    ec.setMinClusterSize(cluster_min_);
    ec.setMaxClusterSize(cluster_max_);
    ec.setSearchMethod(tree);
    ec.setInputCloud(cloud_raw);
    ec.extract(cluster_indices);

    // 6) Publish colored clusters cloud (for debugging clarity)
    pcl::PointCloud<pcl::PointXYZRGB>::Ptr colored(new pcl::PointCloud<pcl::PointXYZRGB>);
    colored->reserve(cloud_raw->size());

    visualization_msgs::MarkerArray marr;
    int id = 0;

    for (const auto& cidx : cluster_indices) {
      // Build cluster cloud
      pcl::PointCloud<pcl::PointXYZI>::Ptr cluster(new pcl::PointCloud<pcl::PointXYZI>);
      cluster->reserve(cidx.indices.size());
      for (int idx_pt : cidx.indices) cluster->push_back((*cloud_raw)[idx_pt]);

      // Centroid
      Eigen::Vector4f centroid;
      pcl::compute3DCentroid(*cluster, centroid);

      // Add to colored cloud
      auto col = colorFor(id);
      for (const auto& p : cluster->points) {
        pcl::PointXYZRGB q;
        q.x = p.x; q.y = p.y; q.z = p.z;
        q.r = (uint8_t)(255.0f * col.r);
        q.g = (uint8_t)(255.0f * col.g);
        q.b = (uint8_t)(255.0f * col.b);
        colored->push_back(q);
      }

      // 7) Outline via Concave Hull
      // Project to XY by flattening Z (makes road-like top-down outlines stable)
      pcl::PointCloud<pcl::PointXYZ>::Ptr cluster_xy(new pcl::PointCloud<pcl::PointXYZ>);
      cluster_xy->reserve(cluster->size());
      for (const auto& p : cluster->points) {
        pcl::PointXYZ q;
        q.x = p.x; q.y = p.y; q.z = 0.0f;
        cluster_xy->push_back(q);
      }

      pcl::PointCloud<pcl::PointXYZ>::Ptr hull(new pcl::PointCloud<pcl::PointXYZ>);
      std::vector<pcl::Vertices> polygons;

      pcl::ConcaveHull<pcl::PointXYZ> chull;
      chull.setInputCloud(cluster_xy);
      chull.setAlpha(hull_alpha_);
      chull.reconstruct(*hull, polygons);

      if (hull->size() >= 3) {
        // LINE_STRIP outline marker
        visualization_msgs::Marker outline;
        outline.header = msg->header;
        outline.header.frame_id = fixed_frame_;
        outline.ns = "outlines";
        outline.id = id;
        outline.type = visualization_msgs::Marker::LINE_STRIP;
        outline.action = visualization_msgs::Marker::ADD;
        outline.scale.x = 0.06;  // line thickness
        outline.color = col;

        for (const auto& hp : hull->points) {
          geometry_msgs::Point gp;
          gp.x = hp.x; gp.y = hp.y; gp.z = 0.0;
          outline.points.push_back(gp);
        }
        // close loop
        outline.points.push_back(outline.points.front());
        outline.lifetime = ros::Duration(0.2);
        marr.markers.push_back(outline);

        // TEXT label marker at centroid
        visualization_msgs::Marker label;
        label.header = outline.header;
        label.ns = "labels";
        label.id = 10000 + id;
        label.type = visualization_msgs::Marker::TEXT_VIEW_FACING;
        label.action = visualization_msgs::Marker::ADD;
        label.pose.position.x = centroid[0];
        label.pose.position.y = centroid[1];
        label.pose.position.z = 0.8; // float above ground
        label.scale.z = 0.5;
        label.color.r = 1.0; label.color.g = 1.0; label.color.b = 1.0; label.color.a = 1.0;

        // quick “size hint”
        // (not true classification, but helps: “small blob” vs “wide blob”)
        label.text = "obj_" + std::to_string(id) + " pts=" + std::to_string(cluster->size());
        label.lifetime = ros::Duration(0.2);
        marr.markers.push_back(label);
      }

      id++;
      if (id > 50) break; // safety
    }

    // Publish markers
    pub_markers_.publish(marr);

    // Publish colored cloud
    colored->header.frame_id = fixed_frame_;
    sensor_msgs::PointCloud2 out_msg;
    pcl::toROSMsg(*colored, out_msg);
    out_msg.header = msg->header;
    out_msg.header.frame_id = fixed_frame_;
    pub_objects_cloud_.publish(out_msg);
  }

  void publishEmptyMarkers(const std_msgs::Header& hdr) {
    visualization_msgs::MarkerArray marr;

    // delete old markers so RViz doesn’t keep stale outlines
    visualization_msgs::Marker del;
    del.header = hdr;
    del.header.frame_id = fixed_frame_;
    del.action = visualization_msgs::Marker::DELETEALL;
    marr.markers.push_back(del);
    pub_markers_.publish(marr);
  }
};

int main(int argc, char** argv) {
  ros::init(argc, argv, "object_outlines");
  ObjectOutlinesNode n;
  ros::spin();
  return 0;
}