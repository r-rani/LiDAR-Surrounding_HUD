#include <ros/ros.h>
#include <sensor_msgs/PointCloud2.h>
#include <visualization_msgs/MarkerArray.h>
#include <visualization_msgs/Marker.h>

#include <pcl_conversions/pcl_conversions.h>
#include <pcl/point_types.h>
#include <pcl/point_cloud.h>

#include <pcl/filters/voxel_grid.h>
#include <pcl/filters/passthrough.h>
#include <pcl/filters/extract_indices.h>

#include <pcl/segmentation/sac_segmentation.h>
#include <pcl/segmentation/extract_clusters.h>
#include <pcl/search/kdtree.h>

#include <pcl/common/common.h>
#include <pcl/surface/convex_hull.h>

#include <cmath>
#include <string>

class ObjectOutlinesNode
{
public:
  ObjectOutlinesNode(ros::NodeHandle& nh)
  : nh_(nh)
  {
    // Topics
    nh_.param<std::string>("input_topic", input_topic_, std::string("/unilidar/cloud"));
    nh_.param<std::string>("frame_id", frame_id_, std::string("unilidar_lidar"));

    // ROI (tune for “road view”)
    nh_.param("x_min", x_min_, 0.5);     // ignore points too close / sensor body
    nh_.param("x_max", x_max_, 50.0);
    nh_.param("y_min", y_min_, -12.0);
    nh_.param("y_max", y_max_,  12.0);
    nh_.param("z_min", z_min_, -2.5);
    nh_.param("z_max", z_max_,  3.0);

    // Downsample
    nh_.param("voxel_leaf", voxel_leaf_, 0.10); // meters

    // Ground plane removal
    nh_.param("ground_dist_thresh", ground_dist_thresh_, 0.18); // meters
    nh_.param("ground_max_iters", ground_max_iters_, 1);        // remove 1 dominant plane

    // Clustering
    nh_.param("cluster_tol", cluster_tol_, 0.40); // meters
    nh_.param("cluster_min", cluster_min_, 80);
    nh_.param("cluster_max", cluster_max_, 20000);

    // Outline
    nh_.param("outline_z_offset", outline_z_offset_, 0.10); // lift outline above object base
    nh_.param("outline_alpha", outline_alpha_, 1.0);
    nh_.param("points_alpha", points_alpha_, 0.9);

    sub_ = nh_.subscribe(input_topic_, 1, &ObjectOutlinesNode::cb, this);

    pub_objects_ = nh_.advertise<sensor_msgs::PointCloud2>("/objects_cloud", 1);
    pub_markers_ = nh_.advertise<visualization_msgs::MarkerArray>("/detected_outlines", 1);

    ROS_INFO_STREAM("ObjectOutlinesNode subscribed to: " << input_topic_);
  }

private:
  using PointT = pcl::PointXYZI;

  void passthrough(pcl::PointCloud<PointT>::Ptr& cloud)
  {
    pcl::PassThrough<PointT> pass;

    pass.setInputCloud(cloud);
    pass.setFilterFieldName("x");
    pass.setFilterLimits(x_min_, x_max_);
    pass.filter(*cloud);

    pass.setInputCloud(cloud);
    pass.setFilterFieldName("y");
    pass.setFilterLimits(y_min_, y_max_);
    pass.filter(*cloud);

    pass.setInputCloud(cloud);
    pass.setFilterFieldName("z");
    pass.setFilterLimits(z_min_, z_max_);
    pass.filter(*cloud);
  }

  void voxelize(pcl::PointCloud<PointT>::Ptr& cloud)
  {
    pcl::VoxelGrid<PointT> vg;
    vg.setInputCloud(cloud);
    vg.setLeafSize(voxel_leaf_, voxel_leaf_, voxel_leaf_);
    vg.filter(*cloud);
  }

  void removeDominantPlane(pcl::PointCloud<PointT>::Ptr& cloud)
  {
    if (cloud->empty()) return;

    pcl::SACSegmentation<PointT> seg;
    seg.setOptimizeCoefficients(true);
    seg.setModelType(pcl::SACMODEL_PLANE);
    seg.setMethodType(pcl::SAC_RANSAC);
    seg.setMaxIterations(200);
    seg.setDistanceThreshold(ground_dist_thresh_);

    pcl::PointIndices::Ptr inliers(new pcl::PointIndices);
    pcl::ModelCoefficients::Ptr coeff(new pcl::ModelCoefficients);

    seg.setInputCloud(cloud);
    seg.segment(*inliers, *coeff);

    if (inliers->indices.size() < 100)
    {
      // If you see “not enough inliers”, it usually means ROI is tiny or cloud is sparse.
      ROS_WARN_STREAM_THROTTLE(1.0, "[plane] Not enough inliers: " << inliers->indices.size());
      return;
    }

    // Remove the plane inliers
    pcl::ExtractIndices<PointT> extract;
    extract.setInputCloud(cloud);
    extract.setIndices(inliers);
    extract.setNegative(true);

    pcl::PointCloud<PointT>::Ptr no_plane(new pcl::PointCloud<PointT>);
    extract.filter(*no_plane);
    cloud.swap(no_plane);
  }

  visualization_msgs::Marker makeLineStrip(int id, const std::string& ns) const
  {
    visualization_msgs::Marker m;
    m.header.frame_id = frame_id_;
    m.header.stamp = ros::Time::now();
    m.ns = ns;
    m.id = id;
    m.type = visualization_msgs::Marker::LINE_STRIP;
    m.action = visualization_msgs::Marker::ADD;
    m.pose.orientation.w = 1.0;
    m.scale.x = 0.05; // line width in meters (tune)
    m.color.a = outline_alpha_;
    return m;
  }

  visualization_msgs::Marker makeText(int id, const std::string& ns) const
  {
    visualization_msgs::Marker m;
    m.header.frame_id = frame_id_;
    m.header.stamp = ros::Time::now();
    m.ns = ns;
    m.id = id;
    m.type = visualization_msgs::Marker::TEXT_VIEW_FACING;
    m.action = visualization_msgs::Marker::ADD;
    m.pose.orientation.w = 1.0;
    m.scale.z = 0.6; // text height
    m.color.a = 1.0;
    m.color.r = 1.0;
    m.color.g = 1.0;
    m.color.b = 1.0;
    return m;
  }

  void cb(const sensor_msgs::PointCloud2ConstPtr& msg)
  {
    // Convert
    pcl::PointCloud<PointT>::Ptr cloud(new pcl::PointCloud<PointT>);
    pcl::fromROSMsg(*msg, *cloud);
    if (cloud->empty()) return;

    // Ensure frame id matches your RViz fixed frame
    frame_id_ = msg->header.frame_id.empty() ? frame_id_ : msg->header.frame_id;

    // ROI + downsample
    passthrough(cloud);
    voxelize(cloud);

    // Remove floor (dominant plane once)
    for (int i = 0; i < ground_max_iters_; ++i)
      removeDominantPlane(cloud);

    if (cloud->empty())
      return;

    // Cluster
    pcl::search::KdTree<PointT>::Ptr tree(new pcl::search::KdTree<PointT>);
    tree->setInputCloud(cloud);

    std::vector<pcl::PointIndices> cluster_indices;
    pcl::EuclideanClusterExtraction<PointT> ec;
    ec.setClusterTolerance(cluster_tol_);
    ec.setMinClusterSize(cluster_min_);
    ec.setMaxClusterSize(cluster_max_);
    ec.setSearchMethod(tree);
    ec.setInputCloud(cloud);
    ec.extract(cluster_indices);

    // Publish objects-only cloud (for clarity)
    sensor_msgs::PointCloud2 out_msg;
    pcl::toROSMsg(*cloud, out_msg);
    out_msg.header = msg->header;
    out_msg.header.frame_id = frame_id_;
    pub_objects_.publish(out_msg);

    visualization_msgs::MarkerArray ma;

    // Clear previous markers (important so RViz doesn’t keep old stuff)
    visualization_msgs::Marker clear;
    clear.header.frame_id = frame_id_;
    clear.header.stamp = ros::Time::now();
    clear.ns = "outlines";
    clear.id = 0;
    clear.action = visualization_msgs::Marker::DELETEALL;
    ma.markers.push_back(clear);

    int obj_id = 0;

    for (const auto& idx : cluster_indices)
    {
      pcl::PointCloud<PointT>::Ptr cluster(new pcl::PointCloud<PointT>);
      cluster->reserve(idx.indices.size());
      for (int ii : idx.indices)
        cluster->push_back((*cloud)[ii]);

      // Compute bbox + centroid for labeling
      PointT minPt, maxPt;
      pcl::getMinMax3D(*cluster, minPt, maxPt);

      float cx = 0.f, cy = 0.f, cz = 0.f;
      for (auto& p : cluster->points) { cx += p.x; cy += p.y; cz += p.z; }
      cx /= cluster->size(); cy /= cluster->size(); cz /= cluster->size();

      float dist = std::sqrt(cx*cx + cy*cy);

      // 2D convex hull in XY for a “true outline”
      pcl::PointCloud<pcl::PointXY>::Ptr pts2d(new pcl::PointCloud<pcl::PointXY>);
      pts2d->reserve(cluster->size());
      for (auto& p : cluster->points)
      {
        pcl::PointXY q;
        q.x = p.x;
        q.y = p.y;
        pts2d->push_back(q);
      }

      pcl::ConvexHull<pcl::PointXY> chull;
      chull.setDimension(2);
      chull.setInputCloud(pts2d);

      pcl::PointCloud<pcl::PointXY> hull2d;
      std::vector<pcl::Vertices> polygons;
      chull.reconstruct(hull2d, polygons);

      if (hull2d.size() < 3)
        continue;

      // Outline marker
      auto line = makeLineStrip(obj_id, "outlines");

      // Color by distance (near = green, far = red-ish)
      float t = std::min(std::max(dist / 30.0f, 0.0f), 1.0f);
      line.color.r = t;
      line.color.g = 1.0f - t;
      line.color.b = 0.1f;

      double z_outline = minPt.z + outline_z_offset_;

      for (size_t i = 0; i < hull2d.size(); i++)
      {
        geometry_msgs::Point gp;
        gp.x = hull2d[i].x;
        gp.y = hull2d[i].y;
        gp.z = z_outline;
        line.points.push_back(gp);
      }
      // close polygon
      line.points.push_back(line.points.front());

      ma.markers.push_back(line);

      // Label marker
      auto text = makeText(10000 + obj_id, "labels");
      text.pose.position.x = cx;
      text.pose.position.y = cy;
      text.pose.position.z = maxPt.z + 0.4;
      text.text = "obj " + std::to_string(obj_id) + "  d=" + std::to_string((int)dist) + "m";
      ma.markers.push_back(text);

      obj_id++;
    }

    pub_markers_.publish(ma);
  }

  ros::NodeHandle nh_;
  ros::Subscriber sub_;
  ros::Publisher pub_objects_;
  ros::Publisher pub_markers_;

  std::string input_topic_;
  std::string frame_id_;

  // ROI
  double x_min_, x_max_, y_min_, y_max_, z_min_, z_max_;

  // Params
  double voxel_leaf_;
  double ground_dist_thresh_;
  int ground_max_iters_;
  double cluster_tol_;
  int cluster_min_, cluster_max_;
  double outline_z_offset_;
  double outline_alpha_;
  double points_alpha_;
};

int main(int argc, char** argv)
{
  ros::init(argc, argv, "object_outlines");
  ros::NodeHandle nh("~");
  ObjectOutlinesNode node(nh);
  ros::spin();
  return 0;
}