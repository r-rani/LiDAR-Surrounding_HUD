#include <ros/ros.h>
#include <sensor_msgs/PointCloud2.h>
#include <visualization_msgs/MarkerArray.h>

#include <pcl_conversions/pcl_conversions.h>
#include <pcl/point_types.h>
#include <pcl/filters/voxel_grid.h>
#include <pcl/filters/passthrough.h>
#include <pcl/filters/extract_indices.h>
#include <pcl/segmentation/sac_segmentation.h>
#include <pcl/segmentation/extract_clusters.h>
#include <pcl/common/common.h>
#include <pcl/common/pca.h>
#include <pcl/search/kdtree.h>

class ObjectOutlines
{
public:
    ObjectOutlines()
    {
        ros::NodeHandle nh("~");

        nh.param<std::string>("input_topic", input_topic_, "/unilidar/cloud");
        nh.param<std::string>("marker_topic", marker_topic_, "/detected_objects");

        sub_ = nh.subscribe(input_topic_, 1, &ObjectOutlines::cloudCallback, this);
        marker_pub_ = nh.advertise<visualization_msgs::MarkerArray>(marker_topic_, 1);

        ROS_INFO("ObjectOutlines running");
    }

private:
    ros::Subscriber sub_;
    ros::Publisher marker_pub_;

    std::string input_topic_;
    std::string marker_topic_;

    void cloudCallback(const sensor_msgs::PointCloud2ConstPtr& msg)
    {
        pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);
        pcl::fromROSMsg(*msg, *cloud);
        if (cloud->empty()) return;

        // ---------- ROI CROP ----------
        pcl::PointCloud<pcl::PointXYZ>::Ptr roi(new pcl::PointCloud<pcl::PointXYZ>);
        pcl::PassThrough<pcl::PointXYZ> pass;

        pass.setInputCloud(cloud);
        pass.setFilterFieldName("x");
        pass.setFilterLimits(0.5, 30.0);
        pass.filter(*roi);

        pass.setInputCloud(roi);
        pass.setFilterFieldName("y");
        pass.setFilterLimits(-6.0, 6.0);
        pass.filter(*roi);

        pass.setInputCloud(roi);
        pass.setFilterFieldName("z");
        pass.setFilterLimits(-1.0, 2.0);
        pass.filter(*roi);

        if (roi->empty()) return;

        // ---------- REMOVE GROUND ----------
        pcl::SACSegmentation<pcl::PointXYZ> seg;
        pcl::PointIndices::Ptr inliers(new pcl::PointIndices);
        pcl::ModelCoefficients::Ptr coeff(new pcl::ModelCoefficients);

        seg.setOptimizeCoefficients(true);
        seg.setModelType(pcl::SACMODEL_PLANE);
        seg.setMethodType(pcl::SAC_RANSAC);
        seg.setDistanceThreshold(0.15);
        seg.setInputCloud(roi);
        seg.segment(*inliers, *coeff);

        pcl::ExtractIndices<pcl::PointXYZ> extract;
        extract.setInputCloud(roi);
        extract.setIndices(inliers);
        extract.setNegative(true);

        pcl::PointCloud<pcl::PointXYZ>::Ptr objects(new pcl::PointCloud<pcl::PointXYZ>);
        extract.filter(*objects);

        if (objects->size() < 30) return;

        // ---------- CLUSTERING ----------
        pcl::search::KdTree<pcl::PointXYZ>::Ptr tree(new pcl::search::KdTree<pcl::PointXYZ>);
        tree->setInputCloud(objects);

        std::vector<pcl::PointIndices> clusters;
        pcl::EuclideanClusterExtraction<pcl::PointXYZ> ec;
        ec.setClusterTolerance(0.5);
        ec.setMinClusterSize(25);
        ec.setMaxClusterSize(2500);
        ec.setSearchMethod(tree);
        ec.setInputCloud(objects);
        ec.extract(clusters);

        visualization_msgs::MarkerArray markers;
        visualization_msgs::Marker clear;
        clear.action = visualization_msgs::Marker::DELETEALL;
        markers.markers.push_back(clear);

        int id = 0;

        for (const auto& cluster : clusters)
        {
            pcl::PointCloud<pcl::PointXYZ>::Ptr c(new pcl::PointCloud<pcl::PointXYZ>);
            for (int idx : cluster.indices)
                c->points.push_back(objects->points[idx]);

            // ---------- PCA (OBB) ----------
            pcl::PCA<pcl::PointXYZ> pca;
            pca.setInputCloud(c);

            Eigen::Vector3f mean = pca.getMean().head<3>();
            Eigen::Matrix3f eig = pca.getEigenVectors();

            Eigen::Matrix4f tf = Eigen::Matrix4f::Identity();
            tf.block<3,3>(0,0) = eig.transpose();
            tf.block<3,1>(0,3) = -eig.transpose() * mean;

            pcl::PointCloud<pcl::PointXYZ>::Ptr proj(new pcl::PointCloud<pcl::PointXYZ>);
            pcl::transformPointCloud(*c, *proj, tf);

            pcl::PointXYZ min_pt, max_pt;
            pcl::getMinMax3D(*proj, min_pt, max_pt);

            Eigen::Vector3f size(max_pt.x - min_pt.x,
                                 max_pt.y - min_pt.y,
                                 max_pt.z - min_pt.z);

            Eigen::Vector3f center = eig * ((min_pt.getVector3fMap() + max_pt.getVector3fMap()) / 2.0f) + mean;
            Eigen::Quaternionf q(eig);

            // ---------- CLASSIFICATION ----------
            bool pedestrian = (size.z() > 1.2 && size.z() < 2.2 &&
                               size.x() < 1.2 && size.y() < 1.2);

            // ---------- BOX ----------
            visualization_msgs::Marker box;
            box.header = msg->header;
            box.ns = "boxes";
            box.id = id++;
            box.type = visualization_msgs::Marker::CUBE;
            box.action = visualization_msgs::Marker::ADD;
            box.pose.position.x = center.x();
            box.pose.position.y = center.y();
            box.pose.position.z = center.z();
            box.pose.orientation.x = q.x();
            box.pose.orientation.y = q.y();
            box.pose.orientation.z = q.z();
            box.pose.orientation.w = q.w();
            box.scale.x = size.x();
            box.scale.y = size.y();
            box.scale.z = size.z();
            box.color.a = 0.6;

            if (pedestrian) {
                box.color.r = 1.0;
                box.color.g = 1.0;
                box.color.b = 0.0;
            } else {
                box.color.r = 0.0;
                box.color.g = 1.0;
                box.color.b = 1.0;
            }

            markers.markers.push_back(box);

            // ---------- LABEL ----------
            visualization_msgs::Marker text;
            text.header = msg->header;
            text.ns = "labels";
            text.id = id++;
            text.type = visualization_msgs::Marker::TEXT_VIEW_FACING;
            text.pose.position.x = center.x();
            text.pose.position.y = center.y();
            text.pose.position.z = center.z() + size.z()/2.0 + 0.3;
            text.scale.z = 0.4;
            text.color.r = 1.0;
            text.color.g = 1.0;
            text.color.b = 1.0;
            text.color.a = 1.0;

            text.text = pedestrian ? "PEDESTRIAN" : "VEHICLE";
            markers.markers.push_back(text);
        }

        marker_pub_.publish(markers);
    }
};

int main(int argc, char** argv)
{
    ros::init(argc, argv, "object_outlines");
    ObjectOutlines node;
    ros::spin();
    return 0;
}