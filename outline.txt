#include <ros/ros.h>
#include <sensor_msgs/PointCloud2.h>
#include <visualization_msgs/MarkerArray.h>
#include <visualization_msgs/Marker.h>

#include <pcl_conversions/pcl_conversions.h>
#include <pcl_ros/point_cloud.h>
#include <pcl/point_types.h>

#include <pcl/filters/voxel_grid.h>
#include <pcl/filters/passthrough.h>
#include <pcl/filters/extract_indices.h>

#include <pcl/segmentation/sac_segmentation.h>
#include <pcl/segmentation/extract_clusters.h>
#include <pcl/search/kdtree.h>

#include <pcl/common/common.h>   // getMinMax3D
#include <pcl/common/centroid.h> // compute3DCentroid

class ObjectOutlines
{
public:
  ObjectOutlines()
  : nh_(), pnh_("~")
  {
    // -------- Params ----------
    pnh_.param<std::string>("input_topic", input_topic_, std::string("/unilidar/cloud"));
    pnh_.param<std::string>("fixed_frame", fixed_frame_, std::string("unilidar_lidar"));

    // ROI crop (tune these first!)
    pnh_.param<double>("x_min", x_min_, 0.3);
    pnh_.param<double>("x_max", x_max_, 10.0);
    pnh_.param<double>("y_min", y_min_, -6.0);
    pnh_.param<double>("y_max", y_max_,  6.0);
    pnh_.param<double>("z_min", z_min_, -0.5);
    pnh_.param<double>("z_max", z_max_,  3.0);

    // Downsample
    pnh_.param<double>("voxel_leaf", voxel_leaf_, 0.05);

    // Ground removal
    pnh_.param<int>("ground_max_iters", ground_max_iters_, 120);
    pnh_.param<double>("ground_dist_thresh", ground_dist_thresh_, 0.08);
    pnh_.param<double>("ground_eps_angle_deg", ground_eps_angle_deg_, 15.0);

    // Wall removal (removes large vertical planes)
    pnh_.param<int>("wall_max_planes", wall_max_planes_, 2);
    pnh_.param<int>("wall_max_iters", wall_max_iters_, 120);
    pnh_.param<double>("wall_dist_thresh", wall_dist_thresh_, 0.10);
    pnh_.param<double>("wall_eps_angle_deg", wall_eps_angle_deg_, 20.0);
    pnh_.param<double>("wall_min_inlier_ratio", wall_min_inlier_ratio_, 0.20); // if plane is >= 20% of points, treat as wall

    // Clustering
    pnh_.param<double>("cluster_tolerance", cluster_tolerance_, 0.35);
    pnh_.param<int>("cluster_min_size", cluster_min_size_, 40);
    pnh_.param<int>("cluster_max_size", cluster_max_size_, 25000);

    // Publish options
    pnh_.param<bool>("publish_text_labels", publish_text_labels_, true);
    pnh_.param<double>("box_line_width", box_line_width_, 0.05);

    // -------- ROS IO ----------
    sub_ = nh_.subscribe(input_topic_, 1, &ObjectOutlines::cloudCb, this);

    markers_pub_ = nh_.advertise<visualization_msgs::MarkerArray>("/detected_objects", 1);

    // Debug clouds (super helpful)
    pub_roi_      = nh_.advertise<sensor_msgs::PointCloud2>("/debug/cloud_roi", 1);
    pub_noground_ = nh_.advertise<sensor_msgs::PointCloud2>("/debug/cloud_noground", 1);
    pub_nowalls_  = nh_.advertise<sensor_msgs::PointCloud2>("/debug/cloud_nowalls", 1);

    ROS_INFO("ObjectOutlines subscribed to: %s", input_topic_.c_str());
  }

private:
  using PointT = pcl::PointXYZI;
  using CloudT = pcl::PointCloud<PointT>;

  ros::NodeHandle nh_;
  ros::NodeHandle pnh_;
  ros::Subscriber sub_;
  ros::Publisher markers_pub_;
  ros::Publisher pub_roi_, pub_noground_, pub_nowalls_;

  std::string input_topic_;
  std::string fixed_frame_;

  double x_min_, x_max_, y_min_, y_max_, z_min_, z_max_;
  double voxel_leaf_;

  int ground_max_iters_;
  double ground_dist_thresh_;
  double ground_eps_angle_deg_;

  int wall_max_planes_;
  int wall_max_iters_;
  double wall_dist_thresh_;
  double wall_eps_angle_deg_;
  double wall_min_inlier_ratio_;

  double cluster_tolerance_;
  int cluster_min_size_, cluster_max_size_;

  bool publish_text_labels_;
  double box_line_width_;

  // ---------- helpers ----------
  CloudT::Ptr voxelDownsample(const CloudT::Ptr& in)
  {
    pcl::VoxelGrid<PointT> vg;
    vg.setInputCloud(in);
    vg.setLeafSize((float)voxel_leaf_, (float)voxel_leaf_, (float)voxel_leaf_);
    CloudT::Ptr out(new CloudT);
    vg.filter(*out);
    return out;
  }

  CloudT::Ptr passThroughROI(const CloudT::Ptr& in)
  {
    CloudT::Ptr tmp(new CloudT), out(new CloudT);

    pcl::PassThrough<PointT> pass;
    pass.setInputCloud(in);
    pass.setFilterFieldName("x");
    pass.setFilterLimits((float)x_min_, (float)x_max_);
    pass.filter(*tmp);

    pass.setInputCloud(tmp);
    pass.setFilterFieldName("y");
    pass.setFilterLimits((float)y_min_, (float)y_max_);
    pass.filter(*tmp);

    pass.setInputCloud(tmp);
    pass.setFilterFieldName("z");
    pass.setFilterLimits((float)z_min_, (float)z_max_);
    pass.filter(*out);

    return out;
  }

  // Remove one plane given a target axis + eps angle constraint
  // If axis is (0,0,1) => planes whose normal is near Z (good for floor)
  // If axis is (1,0,0) or (0,1,0) => planes with normal near X or Y (good for a wall)
  bool removePlaneAxisConstrained(CloudT::Ptr& cloud_io,
                                 const Eigen::Vector3f& axis,
                                 double eps_angle_deg,
                                 int max_iters,
                                 double dist_thresh,
                                 pcl::PointIndices::Ptr& inliers_out)
  {
    if (!cloud_io || cloud_io->empty()) return false;

    pcl::SACSegmentation<PointT> seg;
    seg.setOptimizeCoefficients(true);
    seg.setModelType(pcl::SACMODEL_PERPENDICULAR_PLANE);
    seg.setMethodType(pcl::SAC_RANSAC);
    seg.setMaxIterations(max_iters);
    seg.setDistanceThreshold(dist_thresh);

    seg.setAxis(axis);
    seg.setEpsAngle((float)(eps_angle_deg * M_PI / 180.0));

    pcl::ModelCoefficients::Ptr coeff(new pcl::ModelCoefficients);
    pcl::PointIndices::Ptr inliers(new pcl::PointIndices);

    seg.setInputCloud(cloud_io);
    seg.segment(*inliers, *coeff);

    if (inliers->indices.empty()) return false;

    // Extract non-plane
    pcl::ExtractIndices<PointT> extract;
    extract.setInputCloud(cloud_io);
    extract.setIndices(inliers);
    extract.setNegative(true);

    CloudT::Ptr filtered(new CloudT);
    extract.filter(*filtered);

    cloud_io = filtered;
    inliers_out = inliers;
    return true;
  }

  CloudT::Ptr removeGround(const CloudT::Ptr& in)
  {
    CloudT::Ptr cloud(new CloudT(*in));
    pcl::PointIndices::Ptr inliers;

    bool ok = removePlaneAxisConstrained(
      cloud,
      Eigen::Vector3f(0.f, 0.f, 1.f),
      ground_eps_angle_deg_,
      ground_max_iters_,
      ground_dist_thresh_,
      inliers
    );

    if (!ok) {
      ROS_WARN_THROTTLE(1.0, "Ground plane not found (no removal).");
      return in;
    }
    return cloud;
  }

  CloudT::Ptr removeWalls(const CloudT::Ptr& in)
  {
    CloudT::Ptr cloud(new CloudT(*in));
    if (cloud->empty()) return cloud;

    for (int k = 0; k < wall_max_planes_; ++k)
    {
      if (cloud->empty()) break;

      // Try find a "big wall" plane: normal near X or near Y
      // We'll try both and remove whichever yields more inliers.
      CloudT::Ptr testX(new CloudT(*cloud));
      CloudT::Ptr testY(new CloudT(*cloud));

      pcl::PointIndices::Ptr inX, inY;

      bool okX = removePlaneAxisConstrained(testX, Eigen::Vector3f(1.f, 0.f, 0.f),
                                            wall_eps_angle_deg_, wall_max_iters_, wall_dist_thresh_, inX);
      bool okY = removePlaneAxisConstrained(testY, Eigen::Vector3f(0.f, 1.f, 0.f),
                                            wall_eps_angle_deg_, wall_max_iters_, wall_dist_thresh_, inY);

      // Pick the bigger plane (more inliers)
      int nX = (okX && inX) ? (int)inX->indices.size() : 0;
      int nY = (okY && inY) ? (int)inY->indices.size() : 0;

      int total_before = (int)cloud->size();
      double ratioX = total_before > 0 ? (double)nX / (double)total_before : 0.0;
      double ratioY = total_before > 0 ? (double)nY / (double)total_before : 0.0;

      // Only remove if it's "large enough" to actually be a wall
      if (ratioX < wall_min_inlier_ratio_ && ratioY < wall_min_inlier_ratio_) {
        // No more big walls detected
        break;
      }

      if (ratioX >= ratioY) {
        cloud = testX;
        ROS_INFO_THROTTLE(1.0, "Removed wall plane (X-normal) inliers=%d ratio=%.2f", nX, ratioX);
      } else {
        cloud = testY;
        ROS_INFO_THROTTLE(1.0, "Removed wall plane (Y-normal) inliers=%d ratio=%.2f", nY, ratioY);
      }
    }

    return cloud;
  }

  std::vector<pcl::PointIndices> clusterObjects(const CloudT::Ptr& in)
  {
    std::vector<pcl::PointIndices> clusters;
    if (!in || in->empty()) return clusters;

    pcl::search::KdTree<PointT>::Ptr tree(new pcl::search::KdTree<PointT>);
    tree->setInputCloud(in);

    pcl::EuclideanClusterExtraction<PointT> ec;
    ec.setClusterTolerance(cluster_tolerance_);
    ec.setMinClusterSize(cluster_min_size_);
    ec.setMaxClusterSize(cluster_max_size_);
    ec.setSearchMethod(tree);
    ec.setInputCloud(in);
    ec.extract(clusters);

    return clusters;
  }

  visualization_msgs::Marker makeBoxMarker(const pcl::PointXYZI& min_pt,
                                           const pcl::PointXYZI& max_pt,
                                           const std::string& frame,
                                           int id,
                                           const ros::Time& stamp)
  {
    visualization_msgs::Marker m;
    m.header.frame_id = frame;
    m.header.stamp = stamp;
    m.ns = "boxes";
    m.id = id;
    m.type = visualization_msgs::Marker::LINE_LIST;
    m.action = visualization_msgs::Marker::ADD;

    m.scale.x = box_line_width_; // line width

    // Color: red
    m.color.r = 1.0;
    m.color.g = 0.2;
    m.color.b = 0.2;
    m.color.a = 1.0;

    // 8 corners
    geometry_msgs::Point p[8];
    p[0].x = min_pt.x; p[0].y = min_pt.y; p[0].z = min_pt.z;
    p[1].x = max_pt.x; p[1].y = min_pt.y; p[1].z = min_pt.z;
    p[2].x = max_pt.x; p[2].y = max_pt.y; p[2].z = min_pt.z;
    p[3].x = min_pt.x; p[3].y = max_pt.y; p[3].z = min_pt.z;

    p[4].x = min_pt.x; p[4].y = min_pt.y; p[4].z = max_pt.z;
    p[5].x = max_pt.x; p[5].y = min_pt.y; p[5].z = max_pt.z;
    p[6].x = max_pt.x; p[6].y = max_pt.y; p[6].z = max_pt.z;
    p[7].x = min_pt.x; p[7].y = max_pt.y; p[7].z = max_pt.z;

    auto addEdge = [&](int a, int b){
      m.points.push_back(p[a]);
      m.points.push_back(p[b]);
    };

    // Bottom rectangle
    addEdge(0,1); addEdge(1,2); addEdge(2,3); addEdge(3,0);
    // Top rectangle
    addEdge(4,5); addEdge(5,6); addEdge(6,7); addEdge(7,4);
    // Vertical edges
    addEdge(0,4); addEdge(1,5); addEdge(2,6); addEdge(3,7);

    m.lifetime = ros::Duration(0.2);
    return m;
  }

  visualization_msgs::Marker makeTextMarker(const Eigen::Vector4f& centroid,
                                            const std::string& frame,
                                            int id,
                                            const ros::Time& stamp,
                                            const std::string& text)
  {
    visualization_msgs::Marker t;
    t.header.frame_id = frame;
    t.header.stamp = stamp;
    t.ns = "labels";
    t.id = id;
    t.type = visualization_msgs::Marker::TEXT_VIEW_FACING;
    t.action = visualization_msgs::Marker::ADD;

    t.pose.position.x = centroid[0];
    t.pose.position.y = centroid[1];
    t.pose.position.z = centroid[2] + 0.3; // above object

    t.scale.z = 0.25;
    t.color.r = 1.0;
    t.color.g = 1.0;
    t.color.b = 1.0;
    t.color.a = 1.0;

    t.text = text;
    t.lifetime = ros::Duration(0.2);
    return t;
  }

  void publishDebugCloud(const CloudT::Ptr& cloud, const ros::Publisher& pub,
                         const std::string& frame, const ros::Time& stamp)
  {
    if (pub.getNumSubscribers() == 0) return;
    sensor_msgs::PointCloud2 msg;
    pcl::toROSMsg(*cloud, msg);
    msg.header.frame_id = frame;
    msg.header.stamp = stamp;
    pub.publish(msg);
  }

  void clearOldMarkers(const std::string& frame, const ros::Time& stamp)
  {
    // Optional: publish DELETEALL once in a while, but usually not needed if lifetime is set.
    (void)frame; (void)stamp;
  }

  // ---------- callback ----------
  void cloudCb(const sensor_msgs::PointCloud2ConstPtr& msg)
  {
    const ros::Time stamp = msg->header.stamp;
    const std::string frame = fixed_frame_.empty() ? msg->header.frame_id : fixed_frame_;

    CloudT::Ptr cloud(new CloudT);
    pcl::fromROSMsg(*msg, *cloud);

    if (!cloud || cloud->empty()) {
      ROS_WARN_THROTTLE(1.0, "Received empty cloud");
      return;
    }

    // 1) Downsample
    CloudT::Ptr cloud_ds = voxelDownsample(cloud);

    // 2) ROI crop
    CloudT::Ptr cloud_roi = passThroughROI(cloud_ds);
    publishDebugCloud(cloud_roi, pub_roi_, frame, stamp);

    if (cloud_roi->size() < 50) {
      ROS_WARN_THROTTLE(1.0, "ROI cloud too small (%zu). Tune ROI.", cloud_roi->size());
      // still publish empty markers (clears old)
      visualization_msgs::MarkerArray out;
      markers_pub_.publish(out);
      return;
    }

    // 3) Remove ground
    CloudT::Ptr cloud_noground = removeGround(cloud_roi);
    publishDebugCloud(cloud_noground, pub_noground_, frame, stamp);

    if (cloud_noground->size() < 50) {
      ROS_WARN_THROTTLE(1.0, "After ground removal too small (%zu).", cloud_noground->size());
      visualization_msgs::MarkerArray out;
      markers_pub_.publish(out);
      return;
    }

    // 4) Remove walls (big vertical planes)
    CloudT::Ptr cloud_nowalls = removeWalls(cloud_noground);
    publishDebugCloud(cloud_nowalls, pub_nowalls_, frame, stamp);

    if (cloud_nowalls->size() < 50) {
      ROS_WARN_THROTTLE(1.0, "After wall removal too small (%zu).", cloud_nowalls->size());
      visualization_msgs::MarkerArray out;
      markers_pub_.publish(out);
      return;
    }

    // 5) Cluster objects
    std::vector<pcl::PointIndices> clusters = clusterObjects(cloud_nowalls);
    ROS_INFO_THROTTLE(1.0, "Clusters found=%zu (cloud_nowalls=%zu)", clusters.size(), cloud_nowalls->size());

    // 6) Build markers
    visualization_msgs::MarkerArray out;
    int id = 0;

    for (size_t i = 0; i < clusters.size(); ++i)
    {
      CloudT::Ptr c(new CloudT);
      c->reserve(clusters[i].indices.size());
      for (int idx : clusters[i].indices) c->push_back((*cloud_nowalls)[idx]);

      pcl::PointXYZI min_pt, max_pt;
      pcl::getMinMax3D(*c, min_pt, max_pt);

      // Basic size gating to avoid boxing tiny noise
      double dx = max_pt.x - min_pt.x;
      double dy = max_pt.y - min_pt.y;
      double dz = max_pt.z - min_pt.z;

      // ignore extremely flat or tiny blobs
      if (dx < 0.15 && dy < 0.15) continue;
      if (dz < 0.20) continue; // often floor leftovers

      // box marker
      out.markers.push_back(makeBoxMarker(min_pt, max_pt, frame, id++, stamp));

      // text label
      if (publish_text_labels_) {
        Eigen::Vector4f centroid;
        pcl::compute3DCentroid(*c, centroid);
        std::string label = "obj " + std::to_string(i) +
                            " (" + std::to_string((int)c->size()) + " pts)";
        out.markers.push_back(makeTextMarker(centroid, frame, id++, stamp, label));
      }
    }

    // Publish marker array (empty array => RViz shows 0 markers)
    markers_pub_.publish(out);

    ROS_INFO_THROTTLE(1.0, "Published markers=%zu", out.markers.size());
  }
};

int main(int argc, char** argv)
{
  ros::init(argc, argv, "unitree_outlines");
  ObjectOutlines node;
  ros::spin();
  return 0;
}
