#include <ros/ros.h>
#include <sensor_msgs/PointCloud2.h>
#include <visualization_msgs/MarkerArray.h>

#include <pcl_conversions/pcl_conversions.h>
#include <pcl/point_cloud.h>
#include <pcl/point_types.h>

#include <pcl/filters/extract_indices.h>
#include <pcl/segmentation/sac_segmentation.h>
#include <pcl/segmentation/extract_clusters.h>
#include <pcl/search/kdtree.h>
#include <pcl/surface/concave_hull.h>

class OutlineNode
{
public:
    OutlineNode()
    {
        sub_ = nh_.subscribe("/unilidar/cloud", 1, &OutlineNode::callback, this);
        pub_ = nh_.advertise<visualization_msgs::MarkerArray>("/detected_outlines", 1);
    }

    void callback(const sensor_msgs::PointCloud2ConstPtr& msg)
    {
        pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);
        pcl::fromROSMsg(*msg, *cloud);

        if (cloud->empty()) return;

        // --- Remove floor ---
        pcl::SACSegmentation<pcl::PointXYZ> seg;
        seg.setOptimizeCoefficients(true);
        seg.setModelType(pcl::SACMODEL_PLANE);
        seg.setMethodType(pcl::SAC_RANSAC);
        seg.setDistanceThreshold(0.03);

        pcl::PointIndices::Ptr inliers(new pcl::PointIndices);
        pcl::ModelCoefficients::Ptr coeff(new pcl::ModelCoefficients);

        seg.setInputCloud(cloud);
        seg.segment(*inliers, *coeff);

        pcl::ExtractIndices<pcl::PointXYZ> extract;
        extract.setInputCloud(cloud);
        extract.setIndices(inliers);
        extract.setNegative(true);

        pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_no_floor(new pcl::PointCloud<pcl::PointXYZ>);
        extract.filter(*cloud_no_floor);

        // --- Clustering ---
        pcl::search::KdTree<pcl::PointXYZ>::Ptr tree(new pcl::search::KdTree<pcl::PointXYZ>);
        tree->setInputCloud(cloud_no_floor);

        std::vector<pcl::PointIndices> clusters;
        pcl::EuclideanClusterExtraction<pcl::PointXYZ> ec;
        ec.setClusterTolerance(0.25);
        ec.setMinClusterSize(40);
        ec.setMaxClusterSize(20000);
        ec.setSearchMethod(tree);
        ec.setInputCloud(cloud_no_floor);
        ec.extract(clusters);

        visualization_msgs::MarkerArray markers;
        int id = 0;

        for (auto& c : clusters)
        {
            pcl::PointCloud<pcl::PointXYZ>::Ptr cluster(new pcl::PointCloud<pcl::PointXYZ>);
            for (auto idx : c.indices) cluster->push_back((*cloud_no_floor)[idx]);

            // --- Concave hull ---
            pcl::PointCloud<pcl::PointXYZ>::Ptr hull(new pcl::PointCloud<pcl::PointXYZ>);
            pcl::ConcaveHull<pcl::PointXYZ> chull;
            chull.setInputCloud(cluster);
            chull.setAlpha(0.15);
            chull.reconstruct(*hull);

            if (hull->size() < 3) continue;

            visualization_msgs::Marker m;
            m.header.frame_id = msg->header.frame_id;
            m.header.stamp = ros::Time::now();
            m.ns = "outlines";
            m.id = id++;
            m.type = visualization_msgs::Marker::LINE_STRIP;
            m.action = visualization_msgs::Marker::ADD;
            m.scale.x = 0.03;
            m.color.r = 0.0;
            m.color.g = 1.0;
            m.color.b = 0.0;
            m.color.a = 1.0;

            for (auto& p : hull->points)
            {
                geometry_msgs::Point pt;
                pt.x = p.x;
                pt.y = p.y;
                pt.z = p.z;
                m.points.push_back(pt);
            }

            m.points.push_back(m.points.front()); // close polygon
            markers.markers.push_back(m);
        }

        pub_.publish(markers);
    }

private:
    ros::NodeHandle nh_;
    ros::Subscriber sub_;
    ros::Publisher pub_;
};

int main(int argc, char** argv)
{
    ros::init(argc, argv, "object_outlines");
    OutlineNode n;
    ros::spin();
}