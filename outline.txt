#include <ros/ros.h>
#include <sensor_msgs/PointCloud2.h>
#include <visualization_msgs/MarkerArray.h>

#include <pcl_ros/point_cloud.h>
#include <pcl_conversions/pcl_conversions.h>

#include <pcl/point_types.h>
#include <pcl/filters/voxel_grid.h>
#include <pcl/filters/passthrough.h>
#include <pcl/search/kdtree.h>
#include <pcl/segmentation/extract_clusters.h>

class UnitreeOutlines
{
public:
    UnitreeOutlines()
    {
        ros::NodeHandle nh("~");

        nh.param<std::string>("input_topic", input_topic_, "/unilidar/cloud");
        nh.param<std::string>("marker_topic", marker_topic_, "/unitree/outlines");

        nh.param("voxel_leaf", voxel_leaf_, 0.15);
        nh.param("z_min", z_min_, -1.0);
        nh.param("z_max", z_max_, 2.0);
        nh.param("cluster_tol", cluster_tol_, 0.5);
        nh.param("cluster_min", cluster_min_, 30);
        nh.param("cluster_max", cluster_max_, 2000);

        sub_ = nh.subscribe(input_topic_, 1, &UnitreeOutlines::cloudCallback, this);
        pub_ = nh.advertise<visualization_msgs::MarkerArray>(marker_topic_, 1);

        ROS_INFO("Unitree outlines node started");
        ROS_INFO("Subscribing to: %s", input_topic_.c_str());
        ROS_INFO("Publishing markers on: %s", marker_topic_.c_str());
    }

private:
    ros::Subscriber sub_;
    ros::Publisher pub_;

    std::string input_topic_;
    std::string marker_topic_;

    double voxel_leaf_;
    double z_min_;
    double z_max_;
    double cluster_tol_;
    int cluster_min_;
    int cluster_max_;

    void cloudCallback(const sensor_msgs::PointCloud2ConstPtr& msg)
    {
        pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);
        pcl::fromROSMsg(*msg, *cloud);

        if (cloud->empty())
            return;

        // Downsample
        pcl::VoxelGrid<pcl::PointXYZ> vg;
        pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_ds(new pcl::PointCloud<pcl::PointXYZ>);
        vg.setInputCloud(cloud);
        vg.setLeafSize(voxel_leaf_, voxel_leaf_, voxel_leaf_);
        vg.filter(*cloud_ds);

        // Z filter
        pcl::PassThrough<pcl::PointXYZ> pass;
        pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_f(new pcl::PointCloud<pcl::PointXYZ>);
        pass.setInputCloud(cloud_ds);
        pass.setFilterFieldName("z");
        pass.setFilterLimits(z_min_, z_max_);
        pass.filter(*cloud_f);

        if (cloud_f->size() < 20)
            return;

        // Clustering
        pcl::search::KdTree<pcl::PointXYZ>::Ptr tree(new pcl::search::KdTree<pcl::PointXYZ>);
        tree->setInputCloud(cloud_f);

        std::vector<pcl::PointIndices> cluster_indices;
        pcl::EuclideanClusterExtraction<pcl::PointXYZ> ec;
        ec.setClusterTolerance(cluster_tol_);
        ec.setMinClusterSize(cluster_min_);
        ec.setMaxClusterSize(cluster_max_);
        ec.setSearchMethod(tree);
        ec.setInputCloud(cloud_f);
        ec.extract(cluster_indices);

        visualization_msgs::MarkerArray markers;
        int id = 0;

        for (const auto& cluster : cluster_indices)
        {
            float min_x = 1e9, min_y = 1e9, min_z = 1e9;
            float max_x = -1e9, max_y = -1e9, max_z = -1e9;

            for (int idx : cluster.indices)
            {
                const auto& p = cloud_f->points[idx];
                min_x = std::min(min_x, p.x);
                min_y = std::min(min_y, p.y);
                min_z = std::min(min_z, p.z);
                max_x = std::max(max_x, p.x);
                max_y = std::max(max_y, p.y);
                max_z = std::max(max_z, p.z);
            }

            visualization_msgs::Marker box;
            box.header = msg->header;
            box.ns = "unitree_boxes";
            box.id = id++;
            box.type = visualization_msgs::Marker::CUBE;
            box.action = visualization_msgs::Marker::ADD;

            box.pose.position.x = (min_x + max_x) / 2.0;
            box.pose.position.y = (min_y + max_y) / 2.0;
            box.pose.position.z = (min_z + max_z) / 2.0;

            box.pose.orientation.w = 1.0;

            box.scale.x = (max_x - min_x);
            box.scale.y = (max_y - min_y);
            box.scale.z = (max_z - min_z);

            box.color.r = 1.0;
            box.color.g = 0.0;
            box.color.b = 0.0;
            box.color.a = 0.6;

            box.lifetime = ros::Duration(0.1);

            markers.markers.push_back(box);
        }

        pub_.publish(markers);
    }
};

int main(int argc, char** argv)
{
    ros::init(argc, argv, "unitree_outlines");
    UnitreeOutlines node;
    ros::spin();
    return 0;
}