#include <ros/ros.h>
#include <sensor_msgs/PointCloud2.h>

#include <visualization_msgs/MarkerArray.h>
#include <visualization_msgs/Marker.h>

#include <pcl/point_types.h>
#include <pcl/point_cloud.h>

#include <pcl_conversions/pcl_conversions.h>
#include <pcl_ros/point_cloud.h>

#include <pcl/filters/voxel_grid.h>
#include <pcl/filters/passthrough.h>
#include <pcl/filters/extract_indices.h>

#include <pcl/segmentation/sac_segmentation.h>
#include <pcl/segmentation/extract_clusters.h>

#include <pcl/search/kdtree.h>
#include <pcl/common/centroid.h>

#include <pcl/surface/convex_hull.h>

class ObjectOutlinesNode
{
public:
  ObjectOutlinesNode()
  : nh_("~")
  {
    nh_.param<std::string>("input_topic", input_topic_, "/unilidar/cloud");
    nh_.param<std::string>("fixed_frame", fixed_frame_, "unilidar_lidar");

    // Filtering / ROI
    nh_.param<double>("voxel_leaf", voxel_leaf_, 0.10);      // 0.05–0.15 typical
    nh_.param<double>("z_min", z_min_, -1.5);
    nh_.param<double>("z_max", z_max_,  2.5);
    nh_.param<double>("max_range", max_range_, 30.0);        // meters, optional crop

    // Ground plane removal
    nh_.param<double>("ground_dist_thresh", ground_dist_thresh_, 0.15);
    nh_.param<double>("ground_eps_angle_deg", ground_eps_angle_deg_, 15.0);

    // Remove big planes (walls/tables) after ground removed
    nh_.param<int>("max_plane_iterations", max_plane_iterations_, 3);
    nh_.param<int>("min_plane_inliers", min_plane_inliers_, 300); // raise if still removing people
    nh_.param<double>("plane_dist_thresh", plane_dist_thresh_, 0.12);

    // Clustering
    nh_.param<double>("cluster_tol", cluster_tol_, 0.50);
    nh_.param<int>("cluster_min", cluster_min_, 60);
    nh_.param<int>("cluster_max", cluster_max_, 40000);

    // Outline marker thickness
    nh_.param<double>("line_width", line_width_, 0.08);  // meters

    // Reject clusters that are “too big” (usually walls/table blobs)
    nh_.param<double>("max_cluster_dim_xy", max_cluster_dim_xy_, 6.0); // meters

    // Topics out
    marker_pub_ = nh_.advertise<visualization_msgs::MarkerArray>("/detected_outlines", 1);

    sub_ = nh_.subscribe(input_topic_, 1, &ObjectOutlinesNode::cb, this);

    ROS_INFO("ObjectOutlines subscribed to: %s", input_topic_.c_str());
    ROS_INFO("Publishing MarkerArray: /detected_outlines");
  }

private:
  using PointT = pcl::PointXYZ;
  ros::NodeHandle nh_;
  ros::Subscriber sub_;
  ros::Publisher marker_pub_;

  std::string input_topic_;
  std::string fixed_frame_;

  double voxel_leaf_;
  double z_min_, z_max_;
  double max_range_;

  double ground_dist_thresh_;
  double ground_eps_angle_deg_;

  int max_plane_iterations_;
  int min_plane_inliers_;
  double plane_dist_thresh_;

  double cluster_tol_;
  int cluster_min_, cluster_max_;

  double line_width_;
  double max_cluster_dim_xy_;

  static double deg2rad(double d) { return d * 3.14159265358979323846 / 180.0; }

  void publishDeleteAll(const std_msgs::Header& hdr)
  {
    visualization_msgs::MarkerArray arr;
    visualization_msgs::Marker m;
    m.header = hdr;
    m.header.frame_id = fixed_frame_;
    m.ns = "outlines";
    m.id = 0;
    m.action = visualization_msgs::Marker::DELETEALL;
    arr.markers.push_back(m);
    marker_pub_.publish(arr);
  }

  void cb(const sensor_msgs::PointCloud2ConstPtr& msg)
  {
    if (!msg || msg->data.empty())
      return;

    // 0) Always publish something so rostopic hz shows activity
    // (DELETEALL ensures RViz clears stale outlines when no clusters)
    std_msgs::Header hdr = msg->header;
    hdr.frame_id = fixed_frame_;
    publishDeleteAll(hdr);

    // 1) ROS -> PCL
    pcl::PointCloud<PointT>::Ptr cloud(new pcl::PointCloud<PointT>());
    pcl::fromROSMsg(*msg, *cloud);
    if (cloud->empty()) return;

    // 2) Voxel downsample
    pcl::PointCloud<PointT>::Ptr cloud_ds(new pcl::PointCloud<PointT>());
    pcl::VoxelGrid<PointT> vg;
    vg.setInputCloud(cloud);
    vg.setLeafSize((float)voxel_leaf_, (float)voxel_leaf_, (float)voxel_leaf_);
    vg.filter(*cloud_ds);

    // 3) PassThrough Z (remove ceiling/floor junk)
    pcl::PointCloud<PointT>::Ptr cloud_z(new pcl::PointCloud<PointT>());
    pcl::PassThrough<PointT> pass;
    pass.setInputCloud(cloud_ds);
    pass.setFilterFieldName("z");
    pass.setFilterLimits((float)z_min_, (float)z_max_);
    pass.filter(*cloud_z);

    if (cloud_z->size() < 50) return;

    // 4) Optional max range crop (in XY)
    pcl::PointCloud<PointT>::Ptr cloud_roi(new pcl::PointCloud<PointT>());
    cloud_roi->reserve(cloud_z->size());
    double r2 = max_range_ * max_range_;
    for (const auto& p : cloud_z->points)
    {
      double d2 = p.x*p.x + p.y*p.y;
      if (d2 <= r2) cloud_roi->points.push_back(p);
    }
    cloud_roi->width = (uint32_t)cloud_roi->points.size();
    cloud_roi->height = 1;
    cloud_roi->is_dense = false;

    if (cloud_roi->size() < 50) return;

    // 5) Remove ground plane (prefer plane normal near +Z)
    pcl::SACSegmentation<PointT> seg;
    seg.setOptimizeCoefficients(true);
    seg.setModelType(pcl::SACMODEL_PERPENDICULAR_PLANE);
    seg.setMethodType(pcl::SAC_RANSAC);
    seg.setMaxIterations(120);
    seg.setDistanceThreshold(ground_dist_thresh_);

    Eigen::Vector3f axis(0.0f, 0.0f, 1.0f);
    seg.setAxis(axis);
    seg.setEpsAngle((float)deg2rad(ground_eps_angle_deg_));

    pcl::PointIndices::Ptr inliers_ground(new pcl::PointIndices());
    pcl::ModelCoefficients::Ptr coeff_ground(new pcl::ModelCoefficients());
    seg.setInputCloud(cloud_roi);
    seg.segment(*inliers_ground, *coeff_ground);

    pcl::PointCloud<PointT>::Ptr cloud_noground(new pcl::PointCloud<PointT>());
    if (!inliers_ground->indices.empty())
    {
      pcl::ExtractIndices<PointT> ex;
      ex.setInputCloud(cloud_roi);
      ex.setIndices(inliers_ground);
      ex.setNegative(true);
      ex.filter(*cloud_noground);
    }
    else
    {
      // If no ground found, keep original ROI (don’t kill everything)
      cloud_noground = cloud_roi;
    }

    if (cloud_noground->size() < 50) return;

    // 6) Remove a few largest remaining planes (walls/tables)
    pcl::PointCloud<PointT>::Ptr cloud_noplanes(new pcl::PointCloud<PointT>(*cloud_noground));

    pcl::SACSegmentation<PointT> seg_plane;
    seg_plane.setOptimizeCoefficients(true);
    seg_plane.setModelType(pcl::SACMODEL_PLANE);
    seg_plane.setMethodType(pcl::SAC_RANSAC);
    seg_plane.setMaxIterations(80);
    seg_plane.setDistanceThreshold(plane_dist_thresh_);

    for (int it = 0; it < max_plane_iterations_; ++it)
    {
      if ((int)cloud_noplanes->size() < min_plane_inliers_) break;

      pcl::PointIndices::Ptr inliers_plane(new pcl::PointIndices());
      pcl::ModelCoefficients::Ptr coeff_plane(new pcl::ModelCoefficients());
      seg_plane.setInputCloud(cloud_noplanes);
      seg_plane.segment(*inliers_plane, *coeff_plane);

      if ((int)inliers_plane->indices.size() < min_plane_inliers_)
        break;

      // Remove this plane
      pcl::ExtractIndices<PointT> ex;
      ex.setInputCloud(cloud_noplanes);
      ex.setIndices(inliers_plane);
      ex.setNegative(true);

      pcl::PointCloud<PointT>::Ptr tmp(new pcl::PointCloud<PointT>());
      ex.filter(*tmp);
      cloud_noplanes = tmp;
    }

    if (cloud_noplanes->size() < 50) return;

    // 7) Euclidean clustering
    pcl::search::KdTree<PointT>::Ptr tree(new pcl::search::KdTree<PointT>());
    tree->setInputCloud(cloud_noplanes);

    std::vector<pcl::PointIndices> cluster_indices;
    pcl::EuclideanClusterExtraction<PointT> ec;
    ec.setClusterTolerance(cluster_tol_);
    ec.setMinClusterSize(cluster_min_);
    ec.setMaxClusterSize(cluster_max_);
    ec.setSearchMethod(tree);
    ec.setInputCloud(cloud_noplanes);
    ec.extract(cluster_indices);

    // 8) Build outlines (2D convex hull in XY for each cluster)
    visualization_msgs::MarkerArray arr;

    int id = 0;
    for (const auto& ci : cluster_indices)
    {
      pcl::PointCloud<PointT>::Ptr cluster(new pcl::PointCloud<PointT>());
      cluster->reserve(ci.indices.size());
      for (int idx : ci.indices) cluster->points.push_back(cloud_noplanes->points[idx]);
      cluster->width = (uint32_t)cluster->points.size();
      cluster->height = 1;

      if (cluster->size() < 10) continue;

      // Compute rough XY bounds (reject huge blobs)
      float minx=1e9f,maxx=-1e9f,miny=1e9f,maxy=-1e9f;
      for (auto& p : cluster->points)
      {
        if (p.x < minx) minx = p.x; if (p.x > maxx) maxx = p.x;
        if (p.y < miny) miny = p.y; if (p.y > maxy) maxy = p.y;
      }
      float dx = maxx - minx, dy = maxy - miny;
      if (dx > (float)max_cluster_dim_xy_ || dy > (float)max_cluster_dim_xy_)
        continue;

      // Project to ground (z=0) for a road-map outline
      pcl::PointCloud<PointT>::Ptr cluster_xy(new pcl::PointCloud<PointT>());
      cluster_xy->reserve(cluster->size());
      for (auto p : cluster->points)
      {
        p.z = 0.0f;
        cluster_xy->points.push_back(p);
      }
      cluster_xy->width = (uint32_t)cluster_xy->points.size();
      cluster_xy->height = 1;

      // Convex hull (2D)
      pcl::ConvexHull<PointT> chull;
      chull.setInputCloud(cluster_xy);
      chull.setDimension(2);

      pcl::PointCloud<PointT>::Ptr hull(new pcl::PointCloud<PointT>());
      std::vector<pcl::Vertices> polygons;
      try {
        chull.reconstruct(*hull, polygons);
      } catch (...) {
        continue;
      }

      if (hull->size() < 3) continue;

      // Marker: LINE_STRIP (closed)
      visualization_msgs::Marker m;
      m.header = hdr;
      m.header.frame_id = fixed_frame_;
      m.ns = "outlines";
      m.id = id++;
      m.type = visualization_msgs::Marker::LINE_STRIP;
      m.action = visualization_msgs::Marker::ADD;

      // IMPORTANT: avoid “Uninitialized quaternion” warnings
      m.pose.orientation.w = 1.0;

      m.scale.x = line_width_; // line thickness
      m.color.r = 0.0f;
      m.color.g = 1.0f;
      m.color.b = 0.0f;
      m.color.a = 1.0f;

      // Add hull points, then close loop
      for (const auto& hp : hull->points)
      {
        geometry_msgs::Point gp;
        gp.x = hp.x; gp.y = hp.y; gp.z = 0.05; // slightly above ground
        m.points.push_back(gp);
      }
      m.points.push_back(m.points.front());

      arr.markers.push_back(m);
    }

    // Publish outlines (even empty array is fine; we already sent DELETEALL)
    if (!arr.markers.empty())
      marker_pub_.publish(arr);
  }
};

int main(int argc, char** argv)
{
  ros::init(argc, argv, "object_outlines");
  ObjectOutlinesNode n;
  ros::spin();
  return 0;
}
